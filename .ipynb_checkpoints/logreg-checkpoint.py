{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from  sklearn.metrics import accuracy_score \n",
    "from sklearn.utils import as_float_array\n",
    "import csv\n",
    "import math\n",
    "import collections\n",
    "keys = {'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, \n",
    "        'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11}\n",
    "genreStrings = []\n",
    "allFeaturesMatrix = []\n",
    "allFeaturesDict = {}\n",
    "masterGenreDict = {}\n",
    "genreArrayDict = {}\n",
    "genreToCoefficients = {}\n",
    "genreDict = {}\n",
    "\n",
    "#songToGenre = {}\n",
    "\n",
    "def readMusicData(filename) :\n",
    "    # open a file\n",
    "    with open(filename) as f:\n",
    "        line = csv.reader(f)\n",
    "        # loop over each row in the file\n",
    "        rowNum = 0\n",
    "        for row in line:\n",
    "            if rowNum == 0 : \n",
    "                rowNum += 1\n",
    "                continue\n",
    "            # cast each value to a float\n",
    "            features = []\n",
    "            currFeature = 0\n",
    "            nameID = \"\"\n",
    "            for value in row :\n",
    "                if currFeature ==0:\n",
    "                    if value not in genreStrings:\n",
    "                        genreStrings.append(value)\n",
    "                if (currFeature >= 4 and currFeature <= 8) or currFeature == 10 \\\n",
    "                    or currFeature == 11 or currFeature == 13 or currFeature == 14 \\\n",
    "                        or currFeature == 16: \n",
    "                        value = float(value)\n",
    "                if currFeature == 15 : \n",
    "                    value = int(value[0])\n",
    "                if currFeature == 3 : \n",
    "                    nameID = str(value)\n",
    "                if currFeature == 9 : \n",
    "                    value = keys[value]\n",
    "                if currFeature == 12 : \n",
    "                    value = 1 if value == \"Major\" else 0\n",
    "                features.append(value)\n",
    "                currFeature += 1\n",
    "            allFeaturesDict[nameID] = features\n",
    "            allFeaturesMatrix.append(features)\n",
    "            rowNum += 1\n",
    "        # store the row into our dict\n",
    "\n",
    "def requests(name) :\n",
    "    songRequests = collections.defaultdict(None)\n",
    "    count = 0\n",
    "    with open(name,'r') as file :\n",
    "        for line in file: \n",
    "            if line==\"\\n\":\n",
    "                break\n",
    "#             print(line)\n",
    "            lines = line.split(' = c(')\n",
    "#             print(lines)\n",
    "            name = lines[0]\n",
    "            lines[1] = lines[1].replace('\\\"', \"\")\n",
    "            ids = lines[1].split(\", \")\n",
    "            ids[0] = ids[0].replace('c(', \"\")\n",
    "            ids[4] = ids[4].replace(')\\n', \"\")\n",
    "            songRequests[name] = ids\n",
    "            count += 1\n",
    "            if count == 51 : break\n",
    "    return collections.OrderedDict(sorted(songRequests.items()))\n",
    "\n",
    "def makeGenreDict(filename, genre, genreArray) :\n",
    "    # open a file\n",
    "    with open(filename) as f:\n",
    "        line = csv.reader(f)\n",
    "        # loop over each row in the file\n",
    "        rowNum = 0\n",
    "        for row in line:\n",
    "            if rowNum == 0 : \n",
    "                rowNum += 1\n",
    "                continue\n",
    "            # cast each value to a float\n",
    "            # features = []\n",
    "            currFeature = 0\n",
    "            nameID = \"\"\n",
    "            genreY = 0\n",
    "            gname = \"\"\n",
    "            for value in row :\n",
    "#                 if value==\"Good as Hell\":\n",
    "#                     print(\"ITS IN THERE SOMEWHERE\")\n",
    "                if currFeature ==0:\n",
    "#                     genre = 0\n",
    "                    gname = value\n",
    "                    if value == genre:\n",
    "                        genreY = 1\n",
    "                if currFeature == 3 : \n",
    "                    nameID = str(value)\n",
    "                currFeature+=1\n",
    "            genreDict[nameID] = str(gname)\n",
    "            genreArray.append(genreY)\n",
    "            rowNum += 1\n",
    "#extract numerical features only, with the first value as 'id'\n",
    "def sigmoid(x):\n",
    "    return 1 / (1 + math.exp(-x))\n",
    "def numericalFeaturesOnly(allFeatures, toUse = []) : \n",
    "    newFeatures = []\n",
    "    if not toUse :\n",
    "        for feature in allFeatures :\n",
    "            newFeatures.append(feature[4:])\n",
    "    else : \n",
    "        for feature in allFeatures : \n",
    "            feature = [feature[i] for i in range(len(feature)) if i in toUse]\n",
    "            newFeatures.append(feature)\n",
    "    return newFeatures\n",
    "\n",
    "def outputResults(toUse = [], average = True) :\n",
    "    necessaryDict = {}\n",
    "    totalSongs = 0\n",
    "    numIncorrect = 0 \n",
    "    print(friends)\n",
    "    for person, songIds in friends.items() : \n",
    "        print(person)\n",
    "        songs = []\n",
    "        for song in songIds : \n",
    "            #Using all songs\n",
    "            info = allFeaturesDict[song]\n",
    "            if not toUse : \n",
    "                songs.append(info[4:])\n",
    "                necessaryDict[song] = info[4:]\n",
    "            else : \n",
    "                songs.append([info[i] for i in range(len(info)) if i in toUse])\n",
    "                necessaryDict[song] = [info[i] for i in range(len(info)) if i in toUse]\n",
    "#             print(necessaryDict[song])\n",
    "            totalSongs+=1\n",
    "            \n",
    "        \n",
    "        \n",
    "        print(\"Songs for my friend \" + person)\n",
    "        print(\"\\t Input songs: \")\n",
    "        print(songs)\n",
    "        for song in songIds : \n",
    "            print(\"\\t\\t\" + allFeaturesDict[song][2] + \" by \" + allFeaturesDict[song][1])\n",
    "            scores = []\n",
    "            scoresDict = {}\n",
    "#         for song in songIds:\n",
    "            j=0\n",
    "            for i in range(1, len(genreStrings)):\n",
    "#                 a = allFeaturesDict[song]\n",
    "#                 b = genreToCoefficients[genreStrings[i]]\n",
    "#                 a = map(lambda x: float(x),a)\n",
    "#                 b = map(lambda x: float(x),b)\n",
    "#                 score = a@b\n",
    "#                 print(necessaryDict[song])\n",
    "#                 print(genreToCoefficients[genreStrings[i]][0])\n",
    "                score =  as_float_array(necessaryDict[song], copy=True) @ genreToCoefficients[genreStrings[i]][0]\n",
    "                                             \n",
    "                scores.append(score)\n",
    "                scoresDict[score] = genreStrings[i]\n",
    "            j+=1\n",
    "#             print(scores)\n",
    "\n",
    "            maxScore = max(scores)\n",
    "            print(scoresDict[maxScore])\n",
    "#             print(scores[])\n",
    "            print(\"Correct genre:\")\n",
    "            print(genreDict[song])\n",
    "            print(sigmoid(maxScore + genreToModel[scoresDict[maxScore]].intercept_))\n",
    "            \n",
    "            \n",
    "            if(scoresDict[maxScore]!=genreDict[song]): numIncorrect+=1\n",
    "        # print \"\\t Averaged features: \"\n",
    "        # #average of all the features!\n",
    "        # for line in result : \n",
    "        #     for song in line : \n",
    "        #         print \"\\t\\t\" + allFeaturesMatrix[song][2] + \" by \" + allFeaturesMatrix[song][1]\n",
    "        # print \"\\t Nearest neighbor to individual song: \"\n",
    "#         predicted_classes = model.predict(songs)\n",
    "#         print(predicted_classes)\n",
    "#         totalSongs = 0\n",
    "        #only the nearest neighbor that is not itself!\n",
    "        # for line in result2 : \n",
    "        #     print \"\\t\\t\" + allFeaturesMatrix[line[1]][2] + \" by \" + allFeaturesMatrix[line[1]][1]\n",
    "        print(\"\\n\")\n",
    "    return (numIncorrect, totalSongs)\n",
    "\n",
    "print(\"Reading File Data!\\n\")\n",
    "# Our friend song interests. \n",
    "friends = requests('SongInput.txt')\n",
    "#populate matrix and dict with all features\n",
    "readMusicData('SpotifyFeatures.csv')\n",
    "print(genreStrings)\n",
    "print(len(genreStrings))\n",
    "\n",
    "#Feature indices, beginning at 4 and ending at 16, inclusive. BTW, 12 features total. \n",
    "#first example: all features\n",
    "# desiredFeatures = [i for i in range(4,17)]\n",
    "#second example: \"Danceability, Speechiness, Acousticness, Instrumentalness, Liveness, Valence, Loudness, and Tempo\"\n",
    "desiredFeatures = [4,5,8,10,11,13,14,16]\n",
    "#just the numerical features sans artist/titles/genre/id\n",
    "numericalFeatures = numericalFeaturesOnly(allFeaturesMatrix, desiredFeatures)\n",
    "# model = LogisticRegression()\n",
    "# model.fit(allFeaturesMatrix, genreArray)\n",
    "# print(allFeaturesMatrix)\n",
    "genreToModel = {}\n",
    "print(\"here\")\n",
    "# genreArrays\n",
    "for i in range(1, len(genreStrings)):\n",
    "    mdl = LogisticRegression()\n",
    "    genreArray = []\n",
    "#     genreDict = {}\n",
    "    print(genreStrings[i])\n",
    "    makeGenreDict(\"SpotifyFeatures.csv\", genreStrings[i], genreArray)\n",
    "    \n",
    "#     print(genreArray)\n",
    "    fittedmdl = mdl.fit(numericalFeatures, genreArray)\n",
    "#     print(fittedmdl.coef_)\n",
    "    floats = as_float_array(fittedmdl.coef_, copy=True)\n",
    "    genreToCoefficients[genreStrings[i]] = floats\n",
    "    genreArrayDict[genreStrings[i]] = genreArray\n",
    "    masterGenreDict[genreStrings[i]] = genreDict\n",
    "    genreToModel[genreStrings[i]] = fittedmdl\n",
    "\n",
    "\n",
    "# predicted_classes = model.predict(X)\n",
    "# accuracy = accuracy_score(genreArray.flatten(),predicted_classes)\n",
    "# parameters = model.coef_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "for i in range(1, len(genreStrings)):\n",
    "    print(\"Predicting for \" + genreStrings[i])\n",
    "    outputResults(genreToModel[genreStrings[i]], desiredFeatures)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "print(\"survived the loop\")\n",
    "# print(genreToCoefficients)\n",
    "numIncorrectClass = 0\n",
    "totalClassified = 0\n",
    "\n",
    "numInc, totalUpdate = outputResults(desiredFeatures)\n",
    "totalClassified += totalUpdate\n",
    "numIncorrectClass += numInc\n",
    "print(numIncorrectClass)\n",
    "print(totalClassified)\n",
    "\n",
    "# print(numIncorrect)\n",
    "print(float(numIncorrectClass)/float(totalClassified))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
